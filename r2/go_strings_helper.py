import r2pipe
import re

class GoStringsParser():
    """
    This radare2 script helps to identify strings in Go binaries.

    It finds the references to Go Strings within the binary, creates a flag, and add a comment with the string in the instruction offset.

    Currently supported archs:
     - 386
     - amd64
     - arm
     - arm64
    """

    def __init__(self):
        self.r2 = r2pipe.open()
        self.ptr_sz = 0
        self.search_cmd = ''
        self.arch = ''
        self.bits = 0
       
    def read_strings(self):
        strings = []
        if self._set_arch_params():
            intructions = self.r2.cmdj(self.search_cmd)
            self.r2.cmd('f-hit*') # clean the hits generated by the previous search command
            for instr in intructions:
                str_st_ptr, instr_offset = self._get_str_struct_ptr(instr)
                if str_st_ptr != -1:
                    string = self._get_string(str_st_ptr, instr_offset)
                    if string:
                        strings.append({'string': string, 'offset': instr_offset})
        return strings

    def _set_arch_params(self):
        self.arch = self.r2.cmdj('iAj')['bins'][0]['arch']
        self.bits = self.r2.cmdj('iAj')['bins'][0]['bits']
        if self.arch == 'arm' and self.bits == 64:
            self.ptr_sz = 8
            self.search_cmd = '/cj add x0, x0, 0x'
        elif self.arch == 'arm' and self.bits == 32:
            self.ptr_sz = 4
            self.search_cmd = '/cj ldr r0, [pc, 0x'
        elif self.arch == 'x86' and self.bits == 64:
            self.ptr_sz = 8
            self.search_cmd = '/cj lea rax, [rip +'
        elif self.arch == 'x86' and self.bits == 32:
            self.ptr_sz = 4
            self.search_cmd = '/cj lea eax, [0x'
        else:
            print "Error: Architecture not supported"
            return False
        return True

    def _get_str_struct_ptr(self, instruction):
        instr_offset = instruction['offset']
        if self.arch == 'arm' and self.bits == 64:
            ptr = self._get_arm64_ptr(instr_offset)
            instr_offset = self.r2.cmdj('pdj -1 @ {}'.format(instr_offset))[0].get('offset')
        elif self.arch == 'arm' and self.bits == 32:
            ptr = self.r2.cmdj('pdj 1 @ {}'.format(instr_offset))[0].get('ptr', -1)
            if ptr == -1:
                return ptr, instr_offset
            ptr = self.r2.cmdj('pfj p4 @ {}'.format(ptr))[0]['value']
        elif self.arch == 'x86':
            ptr = self.r2.cmdj('pdj 1 @ {}'.format(instr_offset))[0].get('ptr', -1)
        else:
            print "Error: Architecture not supported"
        return ptr, instr_offset

    def _get_arm64_ptr(self, instr_offset):
        ptr = str(self.r2.cmdj('pdj 1 @ {}'.format(instr_offset))[0].get('opcode').split()[-1])
        ptr = int(ptr, 16)
        ptr_prev = str(self.r2.cmdj('pdj -1 @ {}'.format(instr_offset))[0].get('opcode'))
        if not ptr_prev.startswith('adrp'):
            return -1
        ptr_prev = ptr_prev.split()[-1]
        ptr_prev = int(ptr_prev, 16)
        return ptr + ptr_prev
            
    def _get_string(self, ptr, instr_offset):
        string = ''
        rodata_start, rodata_end = self._get_rodata_limits()
        str_ptr = self.r2.cmdj('pfj p4 @ {}'.format(ptr))[0]['value']
        if rodata_start <= str_ptr <= rodata_end:
            str_sz = self.r2.cmdj('pfj p4 @ {}'.format(ptr+self.ptr_sz))[0]['value']
            if str_sz < 0xff:
                string = self.r2.cmd('ps {} @ {}'.format(str_sz, str_ptr))
        return string

    def _get_rodata_limits(self):
        section = self.r2.cmdj('iSj. @ section..rodata')
        rodata_start = section['vaddr']
        rodata_end = rodata_start + section['vsize']
        return rodata_start, rodata_end     


if __name__ == '__main__':
    go_strings = GoStringsParser()
    strings = go_strings.read_strings()
    print "- Loaded {} string references".format(len(strings))
    r2 = r2pipe.open()
    for string in strings:
        str_flag = 'str.' + re.sub("[^a-zA-Z0-9\n\.]", "_", string['string'][:15])
        r2.cmd('an {} @ {}'.format(str_flag, string['offset']))
        r2.cmd('CCu "{}" @ {}'.format(str_flag, string['offset']))
